(ns tpximpact.datahost.ldapi.models.release
  "Functions in this namespace are a mix of autogenerated (via HugSQL)
  and hand-written utility functions (mostly to hide tedious params
  wrangling).

  Note: Avoid putting complex logic here. Dealing with errors, threads
  pools etc belongs somewhere else.

  ## Conventions
  
  We're using the convetion of aliasing the name of the dynamically selected
  table (e.g. the relase's observations table) as 'selected' in our SQL code."
  (:require [clojure.tools.logging :as log]
            [malli.core :as m]
            [malli.error :as m.error]
            [integrant.core :as ig]
            [hugsql.core :as hugsql]
            [hugsql.adapter.next-jdbc :as next-adapter]
            [hugsql.parameters :refer [identifier-param-quote]]
            [next.jdbc :as jdbc]
            [tpximpact.datahost.ldapi.schemas.common :as s.common]
            [tpximpact.datahost.ldapi.store.sql.interface :as sql.interface]
            [tpximpact.datahost.ldapi.util.name-munging :as name-munging]))

(def ^:private adapter (next-adapter/hugsql-adapter-next-jdbc))
(def ^:private sql-file "tpximpact/datahost/ldapi/models/sql/release.sql")

(defn- setup-queries! []
  (hugsql/def-db-fns sql-file {:adapter adapter :quoting :ansi})
  (hugsql/def-sqlvec-fns sql-file {:adapter adapter :quoting :ansi}))

(setup-queries!)

(defn- release-uri->release-table [release-uri prefix] (->> release-uri name-munging/sanitize-name (str prefix)))

(defn- create-table*
  [db f {:keys [row-schema] :as params} options]
  (let [{:keys [original-column-names col-spec]} (name-munging/observation-column-defs-sql params)
        _ (assert (pos? (count col-spec)))
        col-spec (mapv (fn [tup] {:column (nth tup 1) :spec (nth tup 2)}) col-spec)
        col-spec (assoc-in col-spec [(dec (count col-spec)) :comma?] false)]
    (f db (assoc params :column-spec (map column-spec col-spec)) options)))

(defn create-observations-table
  ([db params] (create-observations-table db params {:quoting :ansi}))
  ([db {:keys [row-schema] :as params} options]
   (create-table* db -create-observations-table params options)))

(defn create-observations-import-table
  [db {:keys [row-schema] :as params} options]
  (create-table* db -create-observations-import-table params options))

(defn create-common-tables
  [^java.sql.Connection db]
  (create-imports-table db)
  (create-commits-table db)
  (create-commits-by-uid-index db)
  (create-commits-by-import-uid-index db)
  (create-commits-by-revision-id-index db)
  (create-commits-by-change-id-index db))

(defn create-release-tables
  "Creates tables for the release specified by URI and row-schema."
  [db {:keys [row-schema release-uri] :as params} options]
  (assert (not (:release-id params)))
  (let [params (assoc params :release_id (name-munging/sanitize-name release-uri))]
    (create-observations-import-table db params options)
    (create-observations-table db params options)))

(def ImportObservationParams
  (m/schema [:map
             [:release_id :string]
             [:import_id :int]
             [:column-names [:sequential :any]]
             [:observations [:sequential :any]]]))

(defn import-observations
  "Adds observations to the 'import' table.
  
  See: [[Importobservationparams]] "
  [db params]
  (assert (m/validate ImportObservationParams params))
  (-import-observations db params))

(defn- sanitize-params
  [{:keys [] :as params} {{:keys [release-uri] :as store} :store  :as options}]
  (cond-> params
    store (assoc :select-columns (sql.interface/-make-select-observations-as store "selected"))))

(def SelectObservationsArgs
  (m/schema [:tuple
             [:fn {:error/message "DB connection is required"} some?]
             [:map
              ;;[:release-uri :datahost/uri]
              [:import-uid :any]]
             [:map
              [:store {:optional false}
               [:and
                [:fn #(satisfies? sql.interface/SQLStoreCompatible %)]
                [:map
                 [:release-uri :datahost/uri]]]]]]
            {:registry s.common/registry}))

(def ^:private select-observation-args-valid? (m/validator SelectObservationsArgs))

(defn- validate-select-observations-args
  [db+params+opts]
  (when-not (select-observation-args-valid? db+params+opts)
    (throw (ex-info "invalid arguments" {:explanation (->> db+params+opts
                                                           (m/explain SelectObservationsArgs)
                                                           (m.error/humanize))}))))

(defn select-imported-observations
  [db {:keys [import-uid] :as params} {{:keys [release-uri]} :store :as options}]
  (validate-select-observations-args [db params options])
  (let [imports-table (release-uri->release-table release-uri "import::")
        params (assoc params
                      :imports-table imports-table
                      :import-id (import-id (assoc params :release-uri release-uri)))]
   (-select-imported-observations db (sanitize-params params options))))

(defn select-observations
  [db {:keys [] :as params} {{:keys [release-uri]} :store :as options}]
  (validate-select-observations-args [db params options])
  (let [observations-table (release-uri->release-table release-uri "observations::")
        params (assoc params
                      :observations-table observations-table
                      :import-id (import-id (assoc params :release-uri release-uri)))]
   (-select-observations db (sanitize-params params options) options)))

(defn complete-import--copy-records
  [db {:keys [import-uid] :as params} {{:keys [release-uri] :as store} :store :as options}]
  (let [observations-table (release-uri->release-table release-uri "observations::")
        imports-table (release-uri->release-table release-uri "import::")
        params (assoc params
                      :observations-table observations-table
                      :imports-table imports-table
                      :select-columns (sql.interface/-make-select-observations-as store nil)
                      :import-id (import-id {:release-uri release-uri :import-uid import-uid}))]
    (-complete-import--copy-records db params options)))

(defn complete-import--delete-import-records
  [db {:keys [import-uid] :as params} {{release-uri :release-uri :as store} :store :as options}]
  (let [params (assoc params :imports-table (release-uri->release-table release-uri "import::"))
        params (assoc params :import-id (import-id (assoc params :release-uri release-uri)))]
   (-complete-import--delete-import-records db params options)))

(defn select-commit-observations
  "Get observations belonging to a commit specified by change-uri.

  Params:
  - change-uri
  - snapshot-data? - optional, defaults to false. Selects only the
    columns needed building a snaphost of the dataset."
  [db {:keys [change-uri snapshot-data?] :as params
       :or {snapshot-data? false}}
   {:keys [store] :as options}]
  (assert store)
  (let [release-uri (:release-uri store)
        observations-table (release-uri->release-table release-uri "observations::")
        params (assoc params :release-uri release-uri :observations-table observations-table)
        params (assoc params :-commit-info (-commit-info params options))
        params (cond-> params
                 (not snapshot-data?) (sanitize-params options)
                 snapshot-data? (assoc :select-columns [["id" "id"]
                                                        ["synth_id" "synth_id"]
                                                        ["coords" "coords"]]))]
    (-select-commit-observations db params options)))

(defn- commit-op-params
  [{:keys [commit-uri snapshot-table] :as params} {:keys [store] :as options}]
  (let [release-uri (:release-uri store)
        params (assoc params :release-uri release-uri)
        params (assoc params :-commit-info (-commit-info params options))
        params (assoc params :observations-table (release-uri->release-table release-uri "observations::"))]
    params))

(defn select-commit-observations-into
  [db {:keys [commit-uri snapshot-table] :as params} {:keys [store] :as options}]
  (assert snapshot-table)
  (let [params (commit-op-params params options)]
    (-select-observation-snapshot-data db params options)))

(defn commit-op-append
  [db {:keys [commit-uri snapshot-table] :as params} {:keys [store] :as options}]
  (assert snapshot-table)
  (let [params (commit-op-params params options)]
    (-commit-op-append db params options)))

(defn commit-op-retract
  [db {:keys [commit-uri snapshot-table] :as params} {:keys [store] :as options}]
  (assert snapshot-table)
  (let [params (commit-op-params params options)]
    (-commit-op-retract db params options)))

(defn commit-op-correct*
  "Note: only performs the 2nd step of 'correction': appending the updated rows
  to a snapshot table that already had the updated rows removed."
  [db {:keys [commit-uri snapshot-table] :as params} {:keys [store] :as options}]
  (assert snapshot-table)
  (let [params (commit-op-params params options)]
    (-commit-op-correct* db params options)))

(defn populate-corrections-scratch-table
  [db {:keys [commit-uri snapshot-table table-name] :as params} {:keys [store] :as options}]
  (assert snapshot-table)
  (let [params (commit-op-params params options)]
    (-populate-corrections-scratch-table db params options)))

(defn commit-op-correct--insert-updated-records
  [db {:keys [commit-uri snapshot-table] :as params} {:keys [store] :as options}]
  (assert snapshot-table)
  (let [params (commit-op-params params options)]
    (-commit-op-correct--insert-updated-records db params options)))

(defn get-commit-ids
  "Returns :id, :parent_id, :op, :uid"
  [db {:keys [commit-uri release-uri] :as params}]
  (assert release-uri)
  (assert commit-uri)
  (-get-commit-ids db (assoc params :all-commit-ids (all-commit-ids {:uid commit-uri :release-uri release-uri}))))

(defn- materialize-snapshot-params+options
  "Returns a tuple of [params options]"
  [ {:keys [snapshots-table] :as params} {:keys [store] :as options}]
  (let [{:keys [release-uri]} store
        params (assoc params
                      :select-columns (sql.interface/-make-select-observations-as store "selected")
                      :observations-table (release-uri->release-table release-uri "observations::"))
        options (cond-> options
                  (not (contains? options :builder-fn))
                  (assoc :builder-fn next.jdbc.result-set/as-unqualified-arrays))]
    [params options]))

(defn materialize-snapshot
  [db {:keys [snapshots-table] :as params} {:keys [store] :as options}]
  (let [[params options] (materialize-snapshot-params+options params options)]
    (jdbc/execute! db (-materialise-snapshot-sqlvec params options) options)))

(defn stream-materialized-snapshot
  [db {:keys [snapshots-table] :as params} {:keys [store] :as options}]
  (let [[params options] (materialize-snapshot-params+options params options)]
    (jdbc/plan db (-materialise-snapshot-sqlvec params options) options)))

(defn drop-release-tables-and-data
  [db {:keys [release-uri] :as params} options]
  (let [imp-table (release-uri->release-table release-uri "import::")
        obs-table (release-uri->release-table release-uri "observations::")]
    (-drop-table db (assoc params :table-name imp-table) options)
    (-drop-table db (assoc params :table-name obs-table) options)
    (jdbc/execute-one! db ["delete from imports where release_uri = ? " release-uri])
    (jdbc/execute-one! db ["delete from commits where release_uri = ?" release-uri])))

(defmethod ig/init-key ::queries [_ _]
  (setup-queries!))

(defmethod ig/halt-key! ::queries [_ _])

(defn db-ok?
  [conn]
  (try
    {:result (jdbc/execute-one! conn ["select count(*) from imports"])} ;TODO: make this work on other DBs
    true
    (catch java.sql.SQLException _ex
      false)))

;;; 'data-source' is optional

(defmethod ig/init-key ::common-tables [_ {{:keys [db-executor db-config data-source]} :db}]
  (let [db-executor ^java.util.concurrent.ExecutorService db-executor
        {:keys [spec user password]} db-config
        connection (if data-source
                     (jdbc/get-connection data-source)
                     (jdbc/get-connection spec user password))]
    (when-not (db-ok? connection)
      (.get (sql.interface/submit db-executor #(create-common-tables connection))))))

(defmethod ig/halt-key! ::common-tables [_ _])
